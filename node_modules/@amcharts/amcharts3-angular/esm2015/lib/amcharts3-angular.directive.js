import { Directive, Input } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./amcharts3-angular.service";
function getType(x) {
    // TODO make this faster ?
    return {}.toString.call(x);
}
function hasOwnKey(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
function copyObject(x) {
    const output = {};
    // TODO use Object.keys ?
    for (const key in x) {
        if (hasOwnKey(x, key)) {
            output[key] = copy(x[key]);
        }
    }
    return output;
}
function copyArray(x) {
    const length = x.length;
    const output = new Array(length);
    for (let i = 0; i < length; ++i) {
        output[i] = copy(x[i]);
    }
    return output;
}
// TODO can this be made faster ?
// TODO what about regexps, etc. ?
function copy(x) {
    switch (getType(x)) {
        case '[object Array]':
            return copyArray(x);
        case '[object Object]':
            return copyObject(x);
        // TODO is this necessary ?
        case '[object Date]':
            return new Date(x.getTime());
        default:
            return x;
    }
}
function isNaN(x) {
    return x !== x;
}
function isNumberEqual(x, y) {
    return x === y || (isNaN(x) && isNaN(y));
}
function removeChartListeners(chart, x, y) {
    if (x !== y) {
        // TODO is this necessary ?
        if (x == null) {
            x = [];
        }
        // TODO is this necessary ?
        if (y == null) {
            y = [];
        }
        const xLength = x.length;
        const yLength = y.length;
        for (let i = 0; i < xLength; ++i) {
            const xValue = x[i];
            let has = false;
            // TODO make this faster ?
            for (let j = 0; j < yLength; ++j) {
                const yValue = y[j];
                // TODO is this correct ?
                if (xValue.event === yValue.event &&
                    xValue.method === yValue.method) {
                    has = true;
                    break;
                }
            }
            if (!has) {
                // TODO is this correct ?
                chart.removeListener(chart, xValue.event, xValue.method);
            }
        }
    }
}
function updateArray(a, x, y) {
    let didUpdate = false;
    if (x !== y) {
        const xLength = x.length;
        const yLength = y.length;
        if (xLength !== yLength) {
            a.length = yLength;
            didUpdate = true;
        }
        for (let i = 0; i < yLength; ++i) {
            if (i < xLength) {
                if (update(a, i, x[i], y[i])) {
                    didUpdate = true;
                }
            }
            else {
                // TODO make this faster ?
                a[i] = copy(y[i]);
                // TODO is this necessary ?
                didUpdate = true;
            }
        }
    }
    return didUpdate;
}
function update(obj, key, x, y) {
    let didUpdate = false;
    if (x !== y) {
        const xType = getType(x);
        const yType = getType(y);
        if (xType === yType) {
            switch (xType) {
                case '[object Array]':
                    if (updateArray(obj[key], x, y)) {
                        didUpdate = true;
                    }
                    break;
                case '[object Object]':
                    if (updateObject(obj[key], x, y)) {
                        didUpdate = true;
                    }
                    break;
                case '[object Date]':
                    if (x.getTime() !== y.getTime()) {
                        // TODO make this faster ?
                        obj[key] = copy(y);
                        didUpdate = true;
                    }
                    break;
                case '[object Number]':
                    if (!isNumberEqual(x, y)) {
                        // TODO is the copy necessary ?
                        obj[key] = copy(y);
                        didUpdate = true;
                    }
                    break;
                default:
                    if (x !== y) {
                        // TODO is the copy necessary ?
                        obj[key] = copy(y);
                        didUpdate = true;
                    }
                    break;
            }
            // TODO is this correct ?
        }
        else {
            // TODO make this faster ?
            obj[key] = copy(y);
            didUpdate = true;
        }
    }
    return didUpdate;
}
function updateObject(chart, oldObj, newObj) {
    let didUpdate = false;
    if (oldObj !== newObj) {
        // TODO use Object.keys ?
        for (const key in newObj) {
            if (hasOwnKey(newObj, key)) {
                // TODO make this faster ?
                if (hasOwnKey(oldObj, key)) {
                    // TODO should this count as an update ?
                    if (key === 'listeners') {
                        // TODO make this faster ?
                        removeChartListeners(chart, oldObj[key], newObj[key]);
                    }
                    if (update(chart, key, oldObj[key], newObj[key])) {
                        didUpdate = true;
                    }
                }
                else {
                    // TODO make this faster ?
                    chart[key] = copy(newObj[key]);
                    didUpdate = true;
                }
            }
        }
        // TODO use Object.keys ?
        for (const key in oldObj) {
            if (hasOwnKey(oldObj, key) && !hasOwnKey(newObj, key)) {
                if (key === 'listeners') {
                    removeChartListeners(chart, oldObj[key], []);
                }
                delete chart[key];
                didUpdate = true;
            }
        }
    }
    return didUpdate;
}
export class AmChartsDirective {
    constructor(el, AmCharts, zone) {
        this.el = el;
        this.AmCharts = AmCharts;
        this.zone = zone;
        this.delay = 0;
    }
    ngAfterViewInit() {
        // AmCharts mutates the config object, so we have to make a deep copy to prevent that
        const props = copy(this.options);
        const el = this.el.nativeElement;
        el.id = this.id;
        el.style.display = 'block';
        this.chart = this.AmCharts.makeChart(this.id, props, this.delay);
    }
    // TODO is this correct ?
    ngOnChanges(x) {
        const el = this.el.nativeElement;
        if (x.id) {
            el.id = x.id.currentValue;
        }
        if (x.options) {
            // Update the chart after init
            if (this.chart) {
                // This is needed to avoid triggering ngDoCheck
                this.zone.runOutsideAngular(() => {
                    const didUpdate = updateObject(this.chart, x.options.previousValue, x.options.currentValue);
                    // TODO make this faster
                    if (didUpdate) {
                        this.chart.validateNow(true);
                    }
                });
            }
        }
    }
    ngOnDestroy() {
        if (this.chart) {
            this.AmCharts.destroyChart(this.chart);
        }
    }
}
AmChartsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.11", ngImport: i0, type: AmChartsDirective, deps: [{ token: i0.ElementRef }, { token: i1.AmChartsService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
AmChartsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.11", type: AmChartsDirective, selector: "amCharts", inputs: { id: "id", options: "options", delay: "delay" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.11", ngImport: i0, type: AmChartsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'amCharts'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.AmChartsService }, { type: i0.NgZone }]; }, propDecorators: { id: [{
                type: Input
            }], options: [{
                type: Input
            }], delay: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1jaGFydHMzLWFuZ3VsYXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW1jaGFydHMvYW1jaGFydHMzLWFuZ3VsYXIvc3JjL2xpYi9hbWNoYXJ0czMtYW5ndWxhci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFNBQVMsRUFBYyxLQUFLLEVBQVUsTUFBTSxlQUFlLENBQUM7OztBQUlyRSxTQUFTLE9BQU8sQ0FBQyxDQUFNO0lBQ3JCLDBCQUEwQjtJQUMxQixPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxHQUFRLEVBQUUsR0FBUTtJQUNuQyxPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBR0QsU0FBUyxVQUFVLENBQUMsQ0FBTTtJQUN4QixNQUFNLE1BQU0sR0FBUSxFQUFFLENBQUM7SUFFdkIseUJBQXlCO0lBQ3pCLEtBQUssTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ25CLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUNyQixNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzVCO0tBQ0Y7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBTTtJQUN2QixNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBRXhCLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWpDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVB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Q0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztvQkFFNUYsd0JBQXdCO29CQUN4QixJQUFJLFNBQVMsRUFBRTt3QkFDYixJQUFJLENBQUMsS0FBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDL0I7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtTQUNGO0lBQ0gsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDZCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDeEM7SUFDSCxDQUFDOzsrR0FqRFUsaUJBQWlCO21HQUFqQixpQkFBaUI7NEZBQWpCLGlCQUFpQjtrQkFIN0IsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsVUFBVTtpQkFDckI7b0pBRVUsRUFBRTtzQkFBVixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNpbXBsZUNoYW5nZXMsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgdHlwZSB7IEFtQ2hhcnQgfSBmcm9tICcuL2FtY2hhcnRzMy1hbmd1bGFyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbUNoYXJ0c1NlcnZpY2UgfSBmcm9tICcuL2FtY2hhcnRzMy1hbmd1bGFyLnNlcnZpY2UnO1xuXG5cbmZ1bmN0aW9uIGdldFR5cGUoeDogYW55KSB7XG4gIC8vIFRPRE8gbWFrZSB0aGlzIGZhc3RlciA/XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpO1xufVxuXG5mdW5jdGlvbiBoYXNPd25LZXkob2JqOiBhbnksIGtleTogYW55KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHg6IGFueSkge1xuICBjb25zdCBvdXRwdXQ6IGFueSA9IHt9O1xuXG4gIC8vIFRPRE8gdXNlIE9iamVjdC5rZXlzID9cbiAgZm9yIChjb25zdCBrZXkgaW4geCkge1xuICAgIGlmIChoYXNPd25LZXkoeCwga2V5KSkge1xuICAgICAgb3V0cHV0W2tleV0gPSBjb3B5KHhba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gY29weUFycmF5KHg6IGFueSkge1xuICBjb25zdCBsZW5ndGggPSB4Lmxlbmd0aDtcblxuICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gY29weSh4W2ldKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIFRPRE8gY2FuIHRoaXMgYmUgbWFkZSBmYXN0ZXIgP1xuLy8gVE9ETyB3aGF0IGFib3V0IHJlZ2V4cHMsIGV0Yy4gP1xuZnVuY3Rpb24gY29weSh4OiBhbnkpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHgpKSB7XG4gIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICByZXR1cm4gY29weUFycmF5KHgpO1xuXG4gIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgcmV0dXJuIGNvcHlPYmplY3QoeCk7XG5cbiAgLy8gVE9ETyBpcyB0aGlzIG5lY2Vzc2FyeSA/XG4gIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgIHJldHVybiBuZXcgRGF0ZSh4LmdldFRpbWUoKSk7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4geDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGlzTmFOKHg6IGFueSkge1xuICByZXR1cm4geCAhPT0geDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJFcXVhbCh4OiBhbnksIHk6IGFueSkge1xuICByZXR1cm4geCA9PT0geSB8fCAoaXNOYU4oeCkgJiYgaXNOYU4oeSkpO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUNoYXJ0TGlzdGVuZXJzKGNoYXJ0OiBhbnksIHg6IGFueSwgeTogYW55KSB7XG4gIGlmICh4ICE9PSB5KSB7XG4gICAgLy8gVE9ETyBpcyB0aGlzIG5lY2Vzc2FyeSA/XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgeCA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE8gaXMgdGhpcyBuZWNlc3NhcnkgP1xuICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgIHkgPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB4TGVuZ3RoID0geC5sZW5ndGg7XG4gICAgY29uc3QgeUxlbmd0aCA9IHkubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4TGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHhWYWx1ZSA9IHhbaV07XG5cbiAgICAgIGxldCBoYXMgPSBmYWxzZTtcblxuICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgZmFzdGVyID9cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgeUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNvbnN0IHlWYWx1ZSA9IHlbal07XG5cbiAgICAgICAgLy8gVE9ETyBpcyB0aGlzIGNvcnJlY3QgP1xuICAgICAgICBpZiAoeFZhbHVlLmV2ZW50ICA9PT0geVZhbHVlLmV2ZW50ICYmXG4gICAgICAgICAgICB4VmFsdWUubWV0aG9kID09PSB5VmFsdWUubWV0aG9kKSB7XG4gICAgICAgICAgaGFzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcykge1xuICAgICAgICAvLyBUT0RPIGlzIHRoaXMgY29ycmVjdCA/XG4gICAgICAgIGNoYXJ0LnJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB4VmFsdWUuZXZlbnQsIHhWYWx1ZS5tZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUFycmF5KGE6IGFueSwgeDogYW55LCB5OiBhbnkpIHtcbiAgbGV0IGRpZFVwZGF0ZSA9IGZhbHNlO1xuXG4gIGlmICh4ICE9PSB5KSB7XG4gICAgY29uc3QgeExlbmd0aCA9IHgubGVuZ3RoO1xuICAgIGNvbnN0IHlMZW5ndGggPSB5Lmxlbmd0aDtcblxuICAgIGlmICh4TGVuZ3RoICE9PSB5TGVuZ3RoKSB7XG4gICAgICBhLmxlbmd0aCA9IHlMZW5ndGg7XG4gICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeUxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA8IHhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHVwZGF0ZShhLCBpLCB4W2ldLCB5W2ldKSkge1xuICAgICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgZmFzdGVyID9cbiAgICAgICAgYVtpXSA9IGNvcHkoeVtpXSk7XG4gICAgICAgIC8vIFRPRE8gaXMgdGhpcyBuZWNlc3NhcnkgP1xuICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWRVcGRhdGU7XG59XG5cblxuZnVuY3Rpb24gdXBkYXRlKG9iajogYW55LCBrZXk6IGFueSwgeDogYW55LCB5OiBhbnkpIHtcbiAgbGV0IGRpZFVwZGF0ZSA9IGZhbHNlO1xuXG4gIGlmICh4ICE9PSB5KSB7XG4gICAgY29uc3QgeFR5cGUgPSBnZXRUeXBlKHgpO1xuICAgIGNvbnN0IHlUeXBlID0gZ2V0VHlwZSh5KTtcblxuICAgIGlmICh4VHlwZSA9PT0geVR5cGUpIHtcbiAgICAgIHN3aXRjaCAoeFR5cGUpIHtcbiAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgICAgaWYgKHVwZGF0ZUFycmF5KG9ialtrZXldLCB4LCB5KSkge1xuICAgICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgICAgIGlmICh1cGRhdGVPYmplY3Qob2JqW2tleV0sIHgsIHkpKSB7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgIGlmICh4LmdldFRpbWUoKSAhPT0geS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBmYXN0ZXIgP1xuICAgICAgICAgIG9ialtrZXldID0gY29weSh5KTtcbiAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICBpZiAoIWlzTnVtYmVyRXF1YWwoeCwgeSkpIHtcbiAgICAgICAgICAvLyBUT0RPIGlzIHRoZSBjb3B5IG5lY2Vzc2FyeSA/XG4gICAgICAgICAgb2JqW2tleV0gPSBjb3B5KHkpO1xuICAgICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh4ICE9PSB5KSB7XG4gICAgICAgICAgLy8gVE9ETyBpcyB0aGUgY29weSBuZWNlc3NhcnkgP1xuICAgICAgICAgIG9ialtrZXldID0gY29weSh5KTtcbiAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gVE9ETyBpcyB0aGlzIGNvcnJlY3QgP1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPIG1ha2UgdGhpcyBmYXN0ZXIgP1xuICAgICAgb2JqW2tleV0gPSBjb3B5KHkpO1xuICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPYmplY3QoY2hhcnQ6IGFueSwgb2xkT2JqOiBhbnksIG5ld09iajogYW55KSB7XG4gIGxldCBkaWRVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAob2xkT2JqICE9PSBuZXdPYmopIHtcbiAgICAvLyBUT0RPIHVzZSBPYmplY3Qua2V5cyA/XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV3T2JqKSB7XG4gICAgICBpZiAoaGFzT3duS2V5KG5ld09iaiwga2V5KSkge1xuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBmYXN0ZXIgP1xuICAgICAgICBpZiAoaGFzT3duS2V5KG9sZE9iaiwga2V5KSkge1xuICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgY291bnQgYXMgYW4gdXBkYXRlID9cbiAgICAgICAgICBpZiAoa2V5ID09PSAnbGlzdGVuZXJzJykge1xuICAgICAgICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgZmFzdGVyID9cbiAgICAgICAgICAgIHJlbW92ZUNoYXJ0TGlzdGVuZXJzKGNoYXJ0LCBvbGRPYmpba2V5XSwgbmV3T2JqW2tleV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cGRhdGUoY2hhcnQsIGtleSwgb2xkT2JqW2tleV0sIG5ld09ialtrZXldKSkge1xuICAgICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBmYXN0ZXIgP1xuICAgICAgICAgIGNoYXJ0W2tleV0gPSBjb3B5KG5ld09ialtrZXldKTtcbiAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyB1c2UgT2JqZWN0LmtleXMgP1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZE9iaikge1xuICAgICAgaWYgKGhhc093bktleShvbGRPYmosIGtleSkgJiYgIWhhc093bktleShuZXdPYmosIGtleSkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2xpc3RlbmVycycpIHtcbiAgICAgICAgICByZW1vdmVDaGFydExpc3RlbmVycyhjaGFydCwgb2xkT2JqW2tleV0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBjaGFydFtrZXldO1xuICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWRVcGRhdGU7XG59XG5cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYW1DaGFydHMnXG59KVxuZXhwb3J0IGNsYXNzIEFtQ2hhcnRzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBpZCE6IHN0cmluZztcbiAgQElucHV0KCkgb3B0aW9uczogYW55OyAvLyBUT0RPIGJldHRlciB0eXBlIGZvciB0aGlzXG4gIEBJbnB1dCgpIGRlbGF5ID0gMDtcblxuICBwcml2YXRlIGNoYXJ0OiBBbUNoYXJ0IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIHByaXZhdGUgQW1DaGFydHM6IEFtQ2hhcnRzU2VydmljZSwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIEFtQ2hhcnRzIG11dGF0ZXMgdGhlIGNvbmZpZyBvYmplY3QsIHNvIHdlIGhhdmUgdG8gbWFrZSBhIGRlZXAgY29weSB0byBwcmV2ZW50IHRoYXRcbiAgICBjb25zdCBwcm9wcyA9IGNvcHkodGhpcy5vcHRpb25zKTtcblxuICAgIGNvbnN0IGVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgZWwuaWQgPSB0aGlzLmlkO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5jaGFydCA9IHRoaXMuQW1DaGFydHMubWFrZUNoYXJ0KHRoaXMuaWQsIHByb3BzLCB0aGlzLmRlbGF5KTtcbiAgfVxuXG4gIC8vIFRPRE8gaXMgdGhpcyBjb3JyZWN0ID9cbiAgbmdPbkNoYW5nZXMoeDogU2ltcGxlQ2hhbmdlcykge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgaWYgKHguaWQpIHtcbiAgICAgIGVsLmlkID0geC5pZC5jdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHgub3B0aW9ucykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBjaGFydCBhZnRlciBpbml0XG4gICAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhdm9pZCB0cmlnZ2VyaW5nIG5nRG9DaGVja1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpZFVwZGF0ZSA9IHVwZGF0ZU9iamVjdCh0aGlzLmNoYXJ0LCB4Lm9wdGlvbnMucHJldmlvdXNWYWx1ZSwgeC5vcHRpb25zLmN1cnJlbnRWYWx1ZSk7XG5cbiAgICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBmYXN0ZXJcbiAgICAgICAgICBpZiAoZGlkVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJ0IS52YWxpZGF0ZU5vdyh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNoYXJ0KSB7XG4gICAgICB0aGlzLkFtQ2hhcnRzLmRlc3Ryb3lDaGFydCh0aGlzLmNoYXJ0KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==